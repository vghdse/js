
/*

$$$$$$\            $$\                                               
$$  __$$\           $$ |                                              
$$ /  \__|$$\   $$\ $$$$$$$\  $$$$$$$$\  $$$$$$\   $$$$$$\   $$$$$$\  
\$$$$$$\  $$ |  $$ |$$  __$$\ \____$$  |$$  __$$\ $$  __$$\ $$  __$$\ 
 \____$$\ $$ |  $$ |$$ |  $$ |  $$$$ _/ $$$$$$$$ |$$ |  \__|$$ /  $$ |
$$\   $$ |$$ |  $$ |$$ |  $$ | $$  _/   $$   ____|$$ |      $$ |  $$ |
\$$$$$$  |\$$$$$$  |$$$$$$$  |$$$$$$$$\ \$$$$$$$\ $$ |      \$$$$$$  |
 \______/  \______/ \_______/ \________| \_______|\__|       \______/

Project Name : SubZero MD
Creator      : Darrell Mucheri ( Mr Frank OFC )
Repo         : https//github.com/mrfrank-ofc/SUBZERO-MD
Support      : wa.me/18062212660
*/










































































































































































































/*
const {
  cmd,
  commands
} = require("../command");
cmd({
  'pattern': "hand",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'âœŠ',
  'filename': __filename
}, async (_0x45cd83, _0x286d49, _0x19855e, {
  from: _0x96d404,
  reply: _0x47c6bc
}) => {
  try {
    const _0x1d39fa = await _0x45cd83.sendMessage(_0x96d404, {
      'text': "âœŠðŸ» *STARTED...* ðŸ’¦"
    });
    const _0x3eccb1 = ['8âœŠï¸===D', "8=âœŠï¸==D", "8==âœŠï¸=D", "8===âœŠï¸D", "8==âœŠï¸=D", "8=âœŠï¸==D", "8âœŠï¸===D", "8=âœŠï¸==D", "8==âœŠï¸=D", '8===âœŠï¸D', "8==âœŠï¸=D", "8=âœŠï¸==D", '8âœŠï¸===D', "8=âœŠï¸==D", "8==âœŠï¸=D", "8===âœŠï¸D", "8==âœŠï¸=D", '8=âœŠï¸==D', "8âœŠï¸===D", '8=âœŠï¸==D', "8==âœŠï¸=D", "8===âœŠï¸D ðŸ’¦", "8==âœŠï¸=DðŸ’¦ ðŸ’¦", "8=âœŠï¸==D ðŸ’¦ðŸ’¦ ðŸ’¦"];
    for (const _0x406c5e of _0x3eccb1) {
      await new Promise(_0x2b41ff => setTimeout(_0x2b41ff, 0x3e8));
      await _0x45cd83.relayMessage(_0x96d404, {
        'protocolMessage': {
          'key': _0x1d39fa.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x406c5e
          }
        }
      }, {});
    }
  } catch (_0x57d8ae) {
    console.log(_0x57d8ae);
    _0x47c6bc("âŒ *Error!* " + _0x57d8ae.message);
  }
});
cmd({
  'pattern': "happy",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ðŸ˜',
  'filename': __filename
}, async (_0x353111, _0x52aa7e, _0x362309, {
  from: _0x3d98dd,
  reply: _0x46f413
}) => {
  try {
    const _0xce6d4d = await _0x353111.sendMessage(_0x3d98dd, {
      'text': 'ðŸ˜‚'
    });
    const _0x47a009 = ['ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜Š', 'ðŸ˜Ž', 'ðŸ¥³', 'ðŸ˜¸', 'ðŸ˜¹', 'ðŸŒž', 'ðŸŒˆ', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜Š', 'ðŸ˜Ž', 'ðŸ¥³', 'ðŸ˜¸', 'ðŸ˜¹', 'ðŸŒž', 'ðŸŒˆ', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜Š'];
    for (const _0x445d2a of _0x47a009) {
      await new Promise(_0x3a1a76 => setTimeout(_0x3a1a76, 0x320));
      await _0x353111.relayMessage(_0x3d98dd, {
        'protocolMessage': {
          'key': _0xce6d4d.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x445d2a
          }
        }
      }, {});
    }
  } catch (_0x3d2162) {
    console.log(_0x3d2162);
    _0x46f413("âŒ *Error!* " + _0x3d2162.message);
  }
});
cmd({
  'pattern': "heart",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ðŸ«€',
  'filename': __filename
}, async (_0x468a9f, _0x3a7e90, _0xac39dc, {
  from: _0x53a037,
  reply: _0x542a66
}) => {
  try {
    const _0x39d571 = await _0x468a9f.sendMessage(_0x53a037, {
      'text': 'â¤ï¸'
    });
    const _0x52271e = ['ðŸ’–', 'ðŸ’—', 'ðŸ’•', 'â¤ï¸', 'ðŸ’›', 'ðŸ’š', 'ðŸ«€', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'â™¥ï¸', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’—', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’˜', 'ðŸ’', 'â™¥ï¸', 'ðŸ’Ÿ', 'ðŸ«€', 'â¤ï¸'];
    for (const _0x42a679 of _0x52271e) {
      await new Promise(_0xc0ed08 => setTimeout(_0xc0ed08, 0x1f4));
      await _0x468a9f.relayMessage(_0x53a037, {
        'protocolMessage': {
          'key': _0x39d571.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x42a679
          }
        }
      }, {});
    }
  } catch (_0x2f7fbb) {
    console.log(_0x2f7fbb);
    _0x542a66("âŒ *Error!* " + _0x2f7fbb.message);
  }
});
cmd({
  'pattern': "anger",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ðŸ¤¡',
  'filename': __filename
}, async (_0x4c63a0, _0x2a2d0f, _0xfd1920, {
  from: _0x7c1f05,
  reply: _0x2fc617
}) => {
  try {
    const _0x471762 = await _0x4c63a0.sendMessage(_0x7c1f05, {
      'text': 'ðŸ¤¡'
    });
    const _0x4383e5 = ['ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ˜¤', 'ðŸ˜¾', 'ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ˜¤', 'ðŸ˜¾'];
    for (const _0x562bf3 of _0x4383e5) {
      await new Promise(_0x2be7c0 => setTimeout(_0x2be7c0, 0x3e8));
      await _0x4c63a0.relayMessage(_0x7c1f05, {
        'protocolMessage': {
          'key': _0x471762.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x562bf3
          }
        }
      }, {});
    }
  } catch (_0x44a0c5) {
    console.log(_0x44a0c5);
    _0x2fc617("âŒ *Error!* " + _0x44a0c5.message);
  }
});
cmd({
  'pattern': "sad",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ðŸ˜«',
  'filename': __filename
}, async (_0x33fcee, _0x1876fe, _0xc17cb8, {
  from: _0x15bb18,
  reply: _0xee066f
}) => {
  try {
    const _0x4c06fd = await _0x33fcee.sendMessage(_0x15bb18, {
      'text': 'ðŸ˜­'
    });
    const _0x2d9a88 = ['ðŸ¥º', 'ðŸ˜Ÿ', 'ðŸ˜•', 'ðŸ˜–', 'ðŸ˜«', 'ðŸ™', 'ðŸ˜©', 'ðŸ˜¥', 'ðŸ˜“', 'ðŸ˜ª', 'ðŸ˜¢', 'ðŸ˜”', 'ðŸ˜ž', 'ðŸ˜­', 'ðŸ’”', 'ðŸ˜­', 'ðŸ˜¿'];
    for (const _0x336d71 of _0x2d9a88) {
      await new Promise(_0x6eece4 => setTimeout(_0x6eece4, 0x3e8));
      await _0x33fcee.relayMessage(_0x15bb18, {
        'protocolMessage': {
          'key': _0x4c06fd.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x336d71
          }
        }
      }, {});
    }
  } catch (_0x345651) {
    console.log(_0x345651);
    _0xee066f("âŒ *Error!* " + _0x345651.message);
  }
});
cmd({
  'pattern': 'shy',
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ðŸ˜³',
  'filename': __filename
}, async (_0x5cfd31, _0x13a257, _0x4fe9cd, {
  from: _0x453318,
  reply: _0x138a01
}) => {
  try {
    const _0x361884 = await _0x5cfd31.sendMessage(_0x453318, {
      'text': "> SUBZERO MD"
    });
    const _0x206081 = ['ðŸ˜³', 'ðŸ˜Š', 'ðŸ˜¶', 'ðŸ™ˆ', 'ðŸ™Š', 'ðŸ˜³', 'ðŸ˜Š', 'ðŸ˜¶', 'ðŸ™ˆ', 'ðŸ™Š'];
    for (const _0x5ccb6e of _0x206081) {
      await new Promise(_0x23b67b => setTimeout(_0x23b67b, 0x3e8));
      await _0x5cfd31.relayMessage(_0x453318, {
        'protocolMessage': {
          'key': _0x361884.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x5ccb6e
          }
        }
      }, {});
    }
  } catch (_0x3775a4) {
    console.log(_0x3775a4);
    _0x138a01("âŒ *Error!* " + _0x3775a4.message);
  }
});
cmd({
  'pattern': "moon",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': 'tools',
  'react': 'ðŸŒ™',
  'filename': __filename
}, async (_0x2adc05, _0x574382, _0xe7924c, {
  from: _0x10f877,
  reply: _0x1797ef
}) => {
  try {
    const _0x16fb04 = await _0x2adc05.sendMessage(_0x10f877, {
      'text': 'ðŸŒ™'
    });
    const _0x226056 = ['ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', "ðŸŒšðŸŒ"];
    for (const _0x3ad6c8 of _0x226056) {
      await new Promise(_0x1eba41 => setTimeout(_0x1eba41, 0x3e8));
      await _0x2adc05.relayMessage(_0x10f877, {
        'protocolMessage': {
          'key': _0x16fb04.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x3ad6c8
          }
        }
      }, {});
    }
  } catch (_0x31361e) {
    console.log(_0x31361e);
    _0x1797ef("âŒ *Error!* " + _0x31361e.message);
  }
});
cmd({
  'pattern': "confused",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': 'tools',
  'react': 'ðŸ™€',
  'filename': __filename
}, async (_0x4e5dcf, _0x197ed7, _0x4e6e55, {
  from: _0x419892,
  reply: _0x1f258d
}) => {
  try {
    const _0x566b9e = await _0x4e5dcf.sendMessage(_0x419892, {
      'text': 'ðŸ™€'
    });
    const _0x35a517 = ['ðŸ˜•', 'ðŸ˜Ÿ', 'ðŸ˜µ', 'ðŸ¤”', 'ðŸ˜–', 'ðŸ˜²', 'ðŸ˜¦', 'ðŸ¤·', "ðŸ¤·â€â™‚ï¸", 'ðŸ¤·â€â™€ï¸'];
    for (const _0x177123 of _0x35a517) {
      await new Promise(_0x19e7ff => setTimeout(_0x19e7ff, 0x3e8));
      await _0x4e5dcf.relayMessage(_0x419892, {
        'protocolMessage': {
          'key': _0x566b9e.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x177123
          }
        }
      }, {});
    }
  } catch (_0x3914f5) {
    console.log(_0x3914f5);
    _0x1f258d("âŒ *Error!* " + _0x3914f5.message);
  }
});
cmd({
  'pattern': 'kiss',
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'â™¥ï¸',
  'filename': __filename
}, async (_0x5534d6, _0xea351e, _0x4a659, {
  from: _0x3549d3,
  reply: _0x38bcdd
}) => {
  try {
    const _0x3d3056 = await _0x5534d6.sendMessage(_0x3549d3, {
      'text': 'â™¥ï¸'
    });
    const _0x548d62 = ['ðŸ¥µ', 'â¤ï¸', 'ðŸ’‹', 'ðŸ˜«', 'ðŸ¤¤', 'ðŸ˜‹', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ™Š', 'ðŸ˜»', 'ðŸ™ˆ', 'ðŸ’‹', 'ðŸ«‚', 'ðŸ«€', 'ðŸ‘…', 'ðŸ‘„', 'ðŸ’‹'];
    for (const _0x2ae417 of _0x548d62) {
      await new Promise(_0x3260b1 => setTimeout(_0x3260b1, 0x3e8));
      await _0x5534d6.relayMessage(_0x3549d3, {
        'protocolMessage': {
          'key': _0x3d3056.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x2ae417
          }
        }
      }, {});
    }
  } catch (_0x1763fc) {
    console.log(_0x1763fc);
    _0x38bcdd("âŒ *Error!* " + _0x1763fc.message);
  }
});
cmd({
  'pattern': 'nikal',
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ðŸ—¿',
  'filename': __filename
}, async (_0x125191, _0x3f957c, _0xb9d01a, {
  from: _0x3ae285,
  reply: _0x30a5f5
}) => {
  try {
    const _0x19567b = await _0x125191.sendMessage(_0x3ae285, {
      'text': "Mr Frank OFCðŸ—¿"
    });
    const _0x1c80f3 = ["â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â žâ ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €     â¢³â¡€â €â¡â €â €â €   â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €  â €    â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Mr   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €      â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €â €__â €   â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â žâ €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£žâ£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â žâ ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €  â €  â¢³â¡€â €â¡â €â €â €   â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €       â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²     â£¿  â£¸   Frank   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €      â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €|__|â €â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â žâ €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£žâ£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â žâ ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €     â €   â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â €â €â €      â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸   OFC   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €     â£¿  â¢¹â €           â¡‡\n  â ™â¢¿â£¯â „â €â €(P)â €â €     â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â žâ €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£žâ£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â žâ ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €     â €   â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €   â €     â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Zimbabwe  â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €        â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €â €__ â €  â €   â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â žâ €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£žâ£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â žâ ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €â €      â¢³â¡€â €â¡â €â €    â €  â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €â € â €      â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²    â£¿  â£¸  Best   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €â €       â£¿  â¢¹â €          â¡‡\n  â ™â¢¿â£¯â „â €â €|__| â €    â¡¿ â €â¡‡â €â €â €â €    â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €â¡´â ƒâ €   â ˜â ¤â£„â£ â žâ €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£žâ£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €â €â €â €â €â €`", "â €â €â €â£ â£¶â¡¾â â ‰â ™â ³â¢¦â¡€â €â €â €â¢ â žâ ‰â ™â ²â¡€â €\n â €â£´â ¿â â €â €â €â €   â €  â €â¢³â¡€â €â¡â €â €       â¢·\nâ¢ â£Ÿâ£‹â¡€â¢€â£€â£€â¡€â €â£€â¡€   â£§â €â¢¸â €  â €       â¡‡\nâ¢¸â£¯â¡­â â ¸â£›â£Ÿâ †â¡´â£»â¡²   â£¿  â£¸   Country   â¡‡\n â£Ÿâ£¿â¡­â €â €â €â €â €â¢±â €       â£¿  â¢¹â €           â¡‡\n  â ™â¢¿â£¯â „â €â €Everâ €â €   â¡¿ â €â¡‡â €â €â €â €   â¡¼\nâ €â €â €â ¹â£¶â †â €â €â €â €â €  â¡´â ƒâ €   â ˜â ¤â£„â£ â žâ €\nâ €â €â €â €â¢¸â£·â¡¦â¢¤â¡¤â¢¤â£žâ£â €â €â €â €â €â €â €â €â €â €\nâ €â¢€â£¤â£´â£¿â£â â €â €â ¸â£â¢¯â£·â£–â£¦â¡€â €â €â €â €â €â €\nâ¢€â£¾â£½â£¿â£¿â£¿â£¿â ›â¢²â£¶â£¾â¢‰â¡·â£¿â£¿â µâ£¿â €â €â €â €â €â €\nâ£¼â£¿â â ‰â£¿â¡­â ‰â ™â¢ºâ£‡â£¼â¡â €â € â €â£„â¢¸â €"];
    for (const _0x77af75 of _0x1c80f3) {
      await new Promise(_0x40d3fb => setTimeout(_0x40d3fb, 0x5dc));
      await _0x125191.relayMessage(_0x3ae285, {
        'protocolMessage': {
          'key': _0x19567b.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x77af75
          }
        }
      }, {});
    }
  } catch (_0x61a6ba) {
    console.log(_0x61a6ba);
    _0x30a5f5("âŒ *Error!* " + _0x61a6ba.message);
  }
});

*/

const { cmd } = require("../command");
const { fetchGif, gifToVideo } = require("../lib/fetchGif");
const axios = require("axios");

cmd(
    {
        pattern: "cry",
        desc: "Send a crying reaction GIF.",
        category: "fun",
        react: "ðŸ˜¢",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is crying over @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is crying!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/cry";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .cry command:", error);
            reply(`âŒ *Error in .cry command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "cuddle",
        desc: "Send a cuddle reaction GIF.",
        category: "fun",
        react: "ðŸ¤—",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} cuddled @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is cuddling everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/cuddle";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .cuddle command:", error);
            reply(`âŒ *Error in .cuddle command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bully",
        desc: "Send a bully reaction GIF.",
        category: "fun",
        react: "ðŸ˜ˆ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is bullying @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is bullying everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/bully";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .bully command:", error);
            reply(`âŒ *Error in .bully command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "hug",
        desc: "Send a hug reaction GIF.",
        category: "fun",
        react: "ðŸ¤—",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} hugged @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is hugging everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ ðŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/hug";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .hug command:", error);
            reply(`âŒ *Error in .hug command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "awoo",
        desc: "Send an awoo reaction GIF.",
        category: "fun",
        react: "ðŸº",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} awoos at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is awooing everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/awoo";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .awoo command:", error);
            reply(`âŒ *Error in .awoo command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "lick",
        desc: "Send a lick reaction GIF.",
        category: "fun",
        react: "ðŸ‘…",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);

            let message = mentionedUser ? `${sender} licked @${mentionedUser.split("@")[0]}` : `${sender} licked themselves!`;

            const apiUrl = "https://api.waifu.pics/sfw/lick";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .lick command:", error);
            reply(`âŒ *Error in .lick command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
  
cmd(
    {
        pattern: "pat",
        desc: "Send a pat reaction GIF.",
        category: "fun",
        react: "ðŸ«‚",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} patted @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is patting everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/pat";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .pat command:", error);
            reply(`âŒ *Error in .pat command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "smug",
        desc: "Send a smug reaction GIF.",
        category: "fun",
        react: "ðŸ˜",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is smug at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is feeling smug!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/smug";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .smug command:", error);
            reply(`âŒ *Error in .smug command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bonk",
        desc: "Send a bonk reaction GIF.",
        category: "fun",
        react: "ðŸ”¨",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} bonked @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is bonking everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/bonk";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .bonk command:", error);
            reply(`âŒ *Error in .bonk command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "yeet",
        desc: "Send a yeet reaction GIF.",
        category: "fun",
        react: "ðŸ’¨",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} yeeted @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is yeeting everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ ðŸ–¤`;

            const apiUrl = "https://api.waifu.pics/sfw/yeet";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .yeet command:", error);
            reply(`âŒ *Error in .yeet command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "blush",
        desc: "Send a blush reaction GIF.",
        category: "fun",
        react: "ðŸ˜Š",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is blushing at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is blushing!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/blush";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .blush command:", error);
            reply(`âŒ *Error in .blush command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);  
  
cmd(
    {
        pattern: "handhold",
        desc: "Send a hand-holding reaction GIF.",
        category: "fun",
        react: "ðŸ¤",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is holding hands with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} wants to hold hands with everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/handhold";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .handhold command:", error);
            reply(`âŒ *Error in .handhold command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "highfive",
        desc: "Send a high-five reaction GIF.",
        category: "fun",
        react: "âœ‹",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} gave a high-five to @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is high-fiving everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/highfive";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .highfive command:", error);
            reply(`âŒ *Error in .highfive command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);  

cmd(
    {
        pattern: "nom",
        desc: "Send a nom reaction GIF.",
        category: "fun",
        react: "ðŸ½ï¸",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is nomming @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is nomming everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/nom";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .nom command:", error);
            reply(`âŒ *Error in .nom command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "wave",
        desc: "Send a wave reaction GIF.",
        category: "fun",
        react: "ðŸ‘‹",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} waved at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is waving at everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/wave";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .wave command:", error);
            reply(`âŒ *Error in .wave command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "smile",
        desc: "Send a smile reaction GIF.",
        category: "fun",
        react: "ðŸ˜",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} smiled at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is smiling at everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/smile";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .smile command:", error);
            reply(`âŒ *Error in .smile command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "wink",
        desc: "Send a wink reaction GIF.",
        category: "fun",
        react: "ðŸ˜‰",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} winked at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is winking at everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/wink";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .wink command:", error);
            reply(`âŒ *Error in .wink command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "happy",
        desc: "Send a happy reaction GIF.",
        category: "fun",
        react: "ðŸ˜Š",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is happy with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is happy with everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/happy";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .happy command:", error);
            reply(`âŒ *Error in .happy command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "glomp",
        desc: "Send a glomp reaction GIF.",
        category: "fun",
        react: "ðŸ¤—",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} glomped @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is glomping everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/glomp";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .glomp command:", error);
            reply(`âŒ *Error in .glomp command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bite",
        desc: "Send a bite reaction GIF.",
        category: "fun",
        react: "ðŸ¦·",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} bit @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is biting everyone!`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/bite";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .bite command:", error);
            reply(`âŒ *Error in .bite command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "poke",
        desc: "Send a poke reaction GIF.",
        category: "fun",
        react: "ðŸ‘‰",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} poked @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} poked everyone`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ `;

            const apiUrl = "https://api.waifu.pics/sfw/poke";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .poke command:", error);
            reply(`âŒ *Error in .poke command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
  
  
cmd(
    {
        pattern: "cringe",
        desc: "Send a cringe reaction GIF.",
        category: "fun",
        react: "ðŸ˜¬",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} thinks @${mentionedUser.split("@")[0]} is cringe`
                : isGroup
                ? `${sender} finds everyone cringe`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/cringe";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .cringe command:", error);
            reply(`âŒ *Error in .cringe command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "dance",
        desc: "Send a dance reaction GIF.",
        category: "fun",
        react: "ðŸ’ƒ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} danced with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is dancing with everyone`
                : `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;

            const apiUrl = "https://api.waifu.pics/sfw/dance";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .dance command:", error);
            reply(`âŒ *Error in .dance command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


  
cmd(
    {
        pattern: "kill",
        desc: "Send a kill reaction GIF.",
        category: "fun",
        react: "ðŸ”ª",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} killed ${target}`;
            } else if (isGroup) {
                message = `${sender} killed everyone`;
            } else {
                message = `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/kill";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .kill command:", error);
            reply(`âŒ *Error in .kill command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "slap",
        desc: "Send a slap reaction GIF.",
        category: "fun",
        react: "âœŠ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} slapped ${target}`;
            } else if (isGroup) {
                message = `${sender} slapped everyone`;
            } else {
                message = `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/slap";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .slap command:", error);
            reply(`âŒ *Error in .slap command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "kiss",
        desc: "Send a kiss reaction GIF.",
        category: "fun",
        react: "ðŸ’‹",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} kissed ${target}`;
            } else if (isGroup) {
                message = `${sender} kissed everyone`;
            } else {
                message = `> Â© ððŽð–ð„ð‘ð„ðƒ ðð˜ ð’ð”ðð™ð„ð‘ðŽ`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/kiss";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("âŒ Error in .kiss command:", error);
            reply(`âŒ *Error in .kiss command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
